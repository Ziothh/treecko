use clap::{Parser, Subcommand};
use treecko::cli::*;

pub enum ProjectTechnology {
    Rust,
    TypeScript,
}
struct Project {
    path: String,
    technology: ProjectTechnology,
}

fn main() {
    handle().unwrap();
}

fn handle() -> Result<(), std::io::Error> {
    let cli = CLI::parse();

    let home = std::env::var("HOME").unwrap();

    // println!("{home:#?}");

    match cli.command.unwrap() {
        Commands::List(args) => {
            let path = shellexpand::tilde(&args.path);

            handle_dirs(std::path::Path::new(&args.path)).unwrap();

            // let a = walkdir::WalkDir::new(path.as_ref());

            // for entry in a {
            //     let entry = entry?;
            //     k

            //     // walkdir::DirEntry

            //     // println!("{:#?}", entry.path())
            // }

            // println!("{path}");
        }
        _ => println!("Not supported or implemented"),
    }

    Ok(())
}

fn handle_dirs(path: &std::path::Path, callback: &dyn Fn(&std::fs::DirEntry)) -> std::io::Result<Option<()>> {
    if path.is_file() {
        return Ok(None);
    }

    let dir_items: Vec<_> = std::fs::read_dir(path)?
        .into_iter()
        .map(|x| x.unwrap())            
        .collect();

    for entry in dir_items {
        let hi = callback(entry);


        println!("{:#?}", entry.path());
    }

    return Ok(Some(()));
}
